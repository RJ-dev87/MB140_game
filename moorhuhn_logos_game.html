<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Moorhuhn-Logos — Demo</title>
  <style>
    :root{--bg:#0b1220;--panel:#111827;--accent:#f59e000;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}    :root{--bg:#0b1220;--panel:#111827;--accent:#f59e0b}
    .hud{width:800px;display:flex;justify-content:space-between;align-items:center;margin:8px 0}
    .hud .score{font-size:20px;font-weight:700}
    .hud .controls{font-size:13px;opacity:0.9}
    .footer{width:800px;color:#cbd5e1;font-size:13px;margin-top:8px}
    button{background:var(--accent);border:none;padding:8px 12px;border-radius:6px;cursor:pointer;font-weight:600}
    .timer{font-size:20px;font-weight:700;margin-left:20px;color:#f59e0b}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="score">Punkte: <span id="score">0</span></div>
      <div class="controls">
        <button id="restart">Neu starten</button>
        <span style="margin-left:12px">Mercedes = -100 Punkte. Klein = 150, Mittel = 100, Groß = 50 Punkte.</span>
      </div>
      <div class="timer">Zeit: <span id="timer">90</span>s</div>
    </div>

    <canvas id="game" width="800" height="600"></canvas>
    <div class="footer">Spawn-Rate, Geschwindigkeit und Bilder leicht anpassbar. Entwickelt als Demo.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const timerEl = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');

  const W = canvas.width, H = canvas.height;

  // Hintergrundbild laden
  const backgroundImg = new Image();
  backgroundImg.src = 'assets/background.png'; // Dein Bild hier
  let bgLoaded = false;
  backgroundImg.onload = () => { bgLoaded = true; };

  // Marken und Logos
  const brands = ['Audi','BMW','Porsche','Tesla','Polestar','BYD','Mercedes'];
  const imagePaths = {
    'Audi': 'assets/audi.png',
    'BMW': 'assets/bmw.png',
    'Porsche': 'assets/porsche.png',
    'Tesla': 'assets/tesla.png',
    'Polestar': 'assets/polestar.png',
    'BYD': 'assets/byd.png',
    'Mercedes': 'assets/mercedes.png'
  };

  let score = 0;
  let entities = [];
  let lastSpawn = 0;
  const spawnInterval = 900;

  const images = {};
  let loaded = 0, toLoad = brands.length;

  let gameTime = 90; // Sekunden
  let running = true;

  function makeFallbackCanvas(text){
    const c = document.createElement('canvas');
    c.width = 120; c.height = 120;
    const cx = c.getContext('2d');
    cx.fillStyle = '#111';
    cx.fillRect(0,0,c.width,c.height);
    cx.fillStyle = '#ddd';
    cx.font = 'bold 28px Arial';
    cx.textAlign = 'center';
    cx.textBaseline = 'middle';
    cx.fillText(text, c.width/2, c.height/2);
    return c;
  }

  brands.forEach(b => {
    const img = new Image();
    img.src = imagePaths[b];
    img.onload = () => { images[b] = img; if(++loaded === toLoad) start(); };
    img.onerror = () => { images[b] = makeFallbackCanvas(b.split(/[- ]/)[0].slice(0,3)); if(++loaded === toLoad) start(); };
  });

  // Größen und Punkte
  const sizeOptions = [
    {size: 40, points: 150}, // klein
    {size: 80, points: 100}, // mittel
    {size: 120, points: 50}  // groß
  ];

  // Geschwindigkeitsoptionen (unabhängig von Größe)
  const speedOptions = [0.6, 1.2, 2.5]; // langsam, mittel, schnell

  function spawnRandom(){
    const brand = brands[Math.floor(Math.random() * brands.length)];
    const sizeData = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];
    const speed = speedOptions[Math.floor(Math.random() * speedOptions.length)];
    const fromLeft = Math.random() < 0.5;
    const x = fromLeft ? -sizeData.size : W + sizeData.size;
    const y = 80 + Math.random() * (H - 160);
    const vx = (fromLeft ? 1 : -1) * speed;
    const rotSpeed = (Math.random()-0.5) * 0.01; // langsamer
    const wavePhase = Math.random() * Math.PI * 2;
    const waveAmplitude = 60 + Math.random() * 40; // stärkere Wellenbewegung
    const waveFrequency = 0.003 + Math.random() * 0.002;
    entities.push({
      x,y,vx,brand,img:images[brand],size:sizeData.size,rot:0,rotSpeed,
      wavePhase,waveAmplitude,waveFrequency,points:sizeData.points
    });
  }

  let lastTime = performance.now();

  function start(){
    score = 0; entities = []; lastSpawn = performance.now(); lastTime = performance.now(); running = true; scoreEl.textContent = score;
    gameTime = 90; timerEl.textContent = gameTime;
    requestAnimationFrame(loop);
    countdown();
  }

  function countdown(){
    const interval = setInterval(() => {
      if (!running) { clearInterval(interval); return; }
      gameTime--;
      timerEl.textContent = gameTime;
      if (gameTime <= 0){
        running = false;
        clearInterval(interval);
      }
    }, 1000);
  }

  const floatingTexts = [];

  function loop(t){
    const dt = t - lastTime; lastTime = t;

    if (running && t - lastSpawn > spawnInterval) { spawnRandom(); lastSpawn = t; }

    entities.forEach(e => {
      e.x += e.vx * dt * 0.06;
      e.wavePhase += e.waveFrequency * dt;
      e.y += Math.sin(e.wavePhase) * (e.waveAmplitude * 0.02); // stärkere Wellenbewegung
      e.rot += e.rotSpeed * dt;
    });

    entities = entities.filter(e => e.x > -200 && e.x < W + 200 && e.y > -200 && e.y < H + 200);

    // Hintergrund zeichnen
    if (bgLoaded) {
      ctx.drawImage(backgroundImg, 0, 0, W, H);
    } else {
      ctx.fillStyle = '#0f1724';
      ctx.fillRect(0,0,W,H);
    }

    // Entities zeichnen
    entities.forEach(e => {
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.rotate(e.rot);
      const s = e.size;
      ctx.globalAlpha = 0.25;
      ctx.beginPath(); ctx.ellipse(0, s*0.4, s*0.6, s*0.18, 0, 0, Math.PI*2); ctx.fillStyle = '#000'; ctx.fill();
      ctx.globalAlpha = 1;
      ctx.drawImage(e.img, -s/2, -s/2, s, s);
      ctx.restore();
    });

    // Floating texts (Trefferpunkte)
    floatingTexts.forEach(ft => {
      ctx.globalAlpha = ft.alpha;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold 24px Arial';
      ctx.fillText(ft.text, ft.x, ft.y);
      ft.y -= 0.5;
      ft.alpha -= 0.02;
    });

    // Fadenkreuz
    if (mouse.x !== null){
      ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 18, 0, Math.PI*2);
      ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(mouse.x-28, mouse.y); ctx.lineTo(mouse.x+28, mouse.y); ctx.moveTo(mouse.x, mouse.y-28); ctx.lineTo(mouse.x, mouse.y+28);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff'; ctx.font = '14px Arial'; ctx.fillText('Targets: ' + entities.length, 10, 18);

    if (running) requestAnimationFrame(loop);
    else {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 36px Arial';
      ctx.fillText('Spiel vorbei! Punkte: ' + score, W/2 - 180, H/2);
    }
  }

  const mouse = {x: null, y: null};
  canvas.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width / r.width); mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
  });
  canvas.addEventListener('mouseleave', () => { mouse.x = null; mouse.y = null; });

  canvas.addEventListener('click', e => {
    if (!running) return;
    const r = canvas.getBoundingClientRect();
    const mx = (e.clientX - r.left) * (canvas.width / r.width);
    const my = (e.clientY - r.top) * (canvas.height / r.height);

    for (let i = entities.length - 1; i >= 0; i--){
      const ent = entities[i];
      const dx = mx - ent.x, dy = my - ent.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const hitRadius = ent.size * 0.45;
      if (dist <= hitRadius){
        const points = (ent.brand === 'Mercedes') ? -100 : ent.points;
        score += points;
        scoreEl.textContent = score;

        floatingTexts.push({
          text: (points > 0 ? '+' : '') + points,
          x: ent.x,
          y: ent.y,
          color: points > 0 ? 'lime' : 'red',
          alpha: 1
        });

        spawnHit(ent.x, ent.y);
        entities.splice(i,1);
        break;
      }
    }
  });

  function spawnHit(x,y){
    const particles = [];
    for (let i=0;i<12;i++) particles.push({x,y,vx:(Math.random()-0.5)*4,vy:(Math.random()-0.5)*4,life:60+Math.random()*30});
    let frames = 0;
    function pLoop(){
      frames++;
      ctx.save();
      particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
      particles.forEach(p => { ctx.globalAlpha = Math.max(0, p.life/60); ctx.fillStyle = '#fff'; ctx.fillRect(p.x-2,p.y-2,4,4); });
      ctx.restore();
      if (frames < 18) requestAnimationFrame(pLoop);
    }
    requestAnimationFrame(pLoop);
  }

  restartBtn.addEventListener('click', () => start());

})();
</script>
</body>
</html>
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#132033);font-family:Inter,Arial,Helvetica,sans-serif;color:#fff}
    .wrap{display:flex;flex-direction:column;align-items:center;padding:12px}
